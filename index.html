<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Karl Josefsson Data Viz Final Project</title>
      <script src="https://d3js.org/d3.v7.min.js"></script>
      <style>
          header {
            text-align: center;
            margin: 0 auto;
            max-width: 800px;
          }
          body {
            font-family: Arial, sans-serif;
            margin: 20px;
          }
          .paragraph {
            font-size: 1.2em;
            line-height: 1.5;
            text-align: center;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
            font-style: times;
          }
          .chart-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            background-color: #f9f9f9;
            flex: 1; /* Added to make containers share space equally */
          }
          #chart {
            width: 100%;
            display: flex;
            justify-content: center;
          }
          .dashboard {
            display: flex;
            flex-direction: row;
            gap: 30px;
            margin: 40px;
            justify-content: center;
          }

          .hospitality-dashboard {
            display: flex;
            flex-direction: row;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            justify-content: center;
            margin-bottom: 40px;
          }
          h1 {
            text-align: center;
            color: #333;
          }

          h2 {
            margin-top: 0;
            color: #555;
            text-align: center; /* Center indv chart titles */
          }
          .axis-x path,
          .axis-y path {
            fill: none;
            stroke: black;
            shape-rendering: crispEdges;
          }

          .axis-x .tick line,
          .axis-y .tick line {
            stroke: #ccc;
            stroke-dasharray: 2, 2;
          }

          .axis text {
            font-size: 12px;
          }

          .line {
            fill: none;
            stroke-width: 2.5px;
          }

          .sweden {
            stroke: #9acd32;
          }

          .norway {
            stroke: #0065a4;
          }

          .denmark {
            stroke: #8b0000;
          }

          .denmark-line {
            stroke: #8b0000;
          }

          .sweden-line {
            stroke: #9acd32;
          }

          .norway-line {
            stroke: #0065a4;
          }

          .line.faded {
            opacity: 0.2;
          }

          .line.highlighted {
            stroke-width: 3.5px;
          }

          .tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #666;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            z-index: 1000;
          }

          .tooltip-value {
            font-weight: bold;
          }

          .grid line {
            stroke: #e0e0e0;
            shape-rendering: crispEdges;
          }

          .grid path {
            stroke-width: 0;
          }

          .legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            font-size: 14px;
          }

          .legend-item {
            display: flex;
            align-items: center;
            margin: 0 15px;
            cursor: pointer;
          }

          .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 5px;
          }

          /* Mortality Section */
          .mortality_legend-html {
            text-align: center;
            margin-bottom: 10px;
          }
          .mortality_legend_item {
            display: inline-flex;
            align-items: center;
            margin: 0 12px;
            font-size: 14px;
          }
          .mortality_legend_color {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #333;
          }
          #mortality_chart {
            margin: 0 auto;
            max-width: 900px;
          }
          .mortality_axis_path,
          .mortality_axis_line {
            stroke: #888;
          }
          .mortality_grid_line {
            stroke: #aaa;
            stroke-width: 1.2px;
          }
          .mortality_grid_path {
            stroke: none;
          }
          .trail {
            fill: none;
            stroke-width: 1.5px;
            opacity: 0.7;
          }
          .mortality_dot {
            stroke: #333;
            stroke-width: 1px;
          }
          #mortality_slider_container {
            text-align: center;
            margin-top: 10px;
          }
          #mortality_slider_container input {
            width: 80%;
          }
          #mortality-current-date {
            font-weight: bold;
            margin-left: 10px;
          }
          button {
            display: block;
            margin: 10px auto;
            padding: 8px 16px;
            font-size: 14px;
          }

          .mortality-tooltip {
            position: absolute;
            pointer-events: none;
            background: white;
            border: 1px solid #999;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.1s ease-in-out;
          }
          
      </style>
  </head>
  <body>
      <header>
          <h1>Sweden's COVID-19 approach, a success or a failure?</h1>
          <h2>Author: Karl Fredrik Hu Josefsson</h2>
          <h4>Email: kfhujosefsson@dons.usfca.edu</h4>
      </header>

      // create a paragraph element
      <p class="paragraph">
          This project aims to analyze the COVID-19 response in Sweden, focusing on the effectiveness of their approach compared to other countries. The analysis will include data visualization and statistical analysis to draw conclusions about the success or failure of Sweden's strategy.
          The project will utilize various data sources, including COVID-19 case numbers, vaccination rates, and public health policies. The goal is to provide a comprehensive overview of Sweden's response to the pandemic and its impact on public health.
          The analysis will be presented through interactive visualizations, allowing users to explore the data and draw their own conclusions. The project will also include a discussion of the implications of Sweden's approach for future public health policy and pandemic preparedness.
          The final project will be presented in a web-based format, making it accessible to a wide audience. The use of D3.js for data visualization will enhance the presentation and allow for dynamic exploration of the data.
          The project will be structured as follows:
      </p>

      // timeline

      <p class="paragraph">
        This project aims to analyze the COVID-19 response in Sweden, focusing on the effectiveness of their approach compared to other countries. The analysis will include data visualization and statistical analysis to draw conclusions about the success or failure of Sweden's strategy.
        The project will utilize various data sources, including COVID-19 case numbers, vaccination rates, and public health policies. The goal is to provide a comprehensive overview of Sweden's response to the pandemic and its impact on public health.
        The analysis will be presented through interactive visualizations, allowing users to explore the data and draw their own conclusions. The project will also include a discussion of the implications of Sweden's approach for future public health policy and pandemic preparedness.
        The final project will be presented in a web-based format, making it accessible to a wide audience. The use of D3.js for data visualization will enhance the presentation and allow for dynamic exploration of the data.
        The project will be structured as follows:
      </p>

      // heatmap


      <p class="paragraph">
        This project aims to analyze the COVID-19 response in Sweden, focusing on the effectiveness of their approach compared to other countries. The analysis will include data visualization and statistical analysis to draw conclusions about the success or failure of Sweden's strategy.
        The project will utilize various data sources, including COVID-19 case numbers, vaccination rates, and public health policies. The goal is to provide a comprehensive overview of Sweden's response to the pandemic and its impact on public health.
        The analysis will be presented through interactive visualizations, allowing users to explore the data and draw their own conclusions. The project will also include a discussion of the implications of Sweden's approach for future public health policy and pandemic preparedness.
        The final project will be presented in a web-based format, making it accessible to a wide audience. The use of D3.js for data visualization will enhance the presentation and allow for dynamic exploration of the data.
        The project will be structured as follows:
      </p>


      // GDP & Unemployment
      <div class="dashboard">
        <div class="chart-container">
          <h2>GDP Annual % Change</h2>
          <div id="gdp-chart"></div>
          <div class="legend" id="gdp-legend"></div>
        </div>
  
        <div class="chart-container">
          <h2>Unemployment Rate Annual Change (%)</h2>
          <div id="unemployment-chart"></div>
          <div class="legend" id="unemployment-legend"></div>
        </div>
      </div>


      <p class="paragraph">
        This project aims to analyze the COVID-19 response in Sweden, focusing on the effectiveness of their approach compared to other countries. The analysis will include data visualization and statistical analysis to draw conclusions about the success or failure of Sweden's strategy.
        The project will utilize various data sources, including COVID-19 case numbers, vaccination rates, and public health policies. The goal is to provide a comprehensive overview of Sweden's response to the pandemic and its impact on public health.
        The analysis will be presented through interactive visualizations, allowing users to explore the data and draw their own conclusions. The project will also include a discussion of the implications of Sweden's approach for future public health policy and pandemic preparedness.
        The final project will be presented in a web-based format, making it accessible to a wide audience. The use of D3.js for data visualization will enhance the presentation and allow for dynamic exploration of the data.
        The project will be structured as follows:
      </p>



      // hospitality dashboard


      <h1>Hospital occupancy</h1>
    <div class="hospitality-dashboard">
      <div class="chart-container">
        <h2>Denmark Hospital Occupancy</h2>
        <div id="denmark-chart"></div>
      </div>
      <div class="chart-container">
        <h2>Norway Hospital Occupancy</h2>
        <div id="norway-chart"></div>
      </div>
      <div class="chart-container">
        <h2>Sweden Hospital Occupancy</h2>
        <div id="sweden-chart"></div>
      </div>
    </div>

    <div style="margin-top: 30px; margin-bottom: 40px">
      <div
        class="chart-container"
        style="max-width: 1160px; margin: 0 auto"
      >
        <h2>Combined Hospital Occupancy</h2>
        <div id="combined-chart"></div>
        <div
          class="legend"
          id="combined-legend"
          style="
            display: flex;
            justify-content: center;
            margin-top: 10px;
          "
        ></div>
      </div>
    </div>



      <p class="paragraph">
        This project aims to analyze the COVID-19 response in Sweden, focusing on the effectiveness of their approach compared to other countries. The analysis will include data visualization and statistical analysis to draw conclusions about the success or failure of Sweden's strategy.
        The project will utilize various data sources, including COVID-19 case numbers, vaccination rates, and public health policies. The goal is to provide a comprehensive overview of Sweden's response to the pandemic and its impact on public health.
        The analysis will be presented through interactive visualizations, allowing users to explore the data and draw their own conclusions. The project will also include a discussion of the implications of Sweden's approach for future public health policy and pandemic preparedness.
        The final project will be presented in a web-based format, making it accessible to a wide audience. The use of D3.js for data visualization will enhance the presentation and allow for dynamic exploration of the data.
        The project will be structured as follows:
      </p>

      // mortality chart
      <h1>Scandinavia COVID-19 Deaths Per 10 Million</h1>
      <div class="mortality_legend-html" id="legend">
        <div class="mortality_legend_item">
          <div class="mortality_legend_color" style="background: darkred"></div>
          <div>Denmark</div>
        </div>
        <div class="mortality_legend_item">
          <div class="mortality_legend_color" style="background: steelblue"></div>
          <div>Norway</div>
        </div>
        <div class="mortality_legend_item">
          <div class="mortality_legend_color" style="background: YellowGreen"></div>
          <div>Sweden</div>
        </div>
      </div>
  
      <!-- Added chart container div -->
      <div class="chart-container">
        <div id="chart"></div>
        <button id="play">Play</button>
        <div id="mortality_slider_container">
          <input type="range" id="date-slider" min="0" max="0" step="1" />
          <span id="mortality-current-date"></span>
        </div>
      </div>
  
      <div id="tooltip" class="mortality-tooltip"></div>



      <p class="paragraph">
        This project aims to analyze the COVID-19 response in Sweden, focusing on the effectiveness of their approach compared to other countries. The analysis will include data visualization and statistical analysis to draw conclusions about the success or failure of Sweden's strategy.
        The project will utilize various data sources, including COVID-19 case numbers, vaccination rates, and public health policies. The goal is to provide a comprehensive overview of Sweden's response to the pandemic and its impact on public health.
        The analysis will be presented through interactive visualizations, allowing users to explore the data and draw their own conclusions. The project will also include a discussion of the implications of Sweden's approach for future public health policy and pandemic preparedness.
        The final project will be presented in a web-based format, making it accessible to a wide audience. The use of D3.js for data visualization will enhance the presentation and allow for dynamic exploration of the data.
        The project will be structured as follows:
      </p>



      <script>
        const margin = {
        top: 40,
        right: 50,
        bottom: 60,
        left: 50,
      };
      const width = 550 - margin.left - margin.right; // Reduced width for side-by-side
      const height = 400 - margin.top - margin.bottom;

      //  colors
      const colorScale = d3
        .scaleOrdinal()
        .domain(['Sweden', 'Norway', 'Denmark'])
        .range(['#9acd32', '#0065a4', '#8b0000']);

      // tooltip
      const tooltip = d3
        .select('body')
        .append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

      // process data
      Promise.all([
        d3.csv(
          'https://gist.githubusercontent.com/karldif01/3ca5729a8d4ff777181aa803f4b53b62/raw/8d99d7510a9c3f0d99c4e8d684e4affffd1d055c/gistfile1.txt',
        ),
        d3.csv(
          'https://gist.githubusercontent.com/karldif01/7832f6c3963b1b0a7582267630c90714/raw/8a989fbf46744922e99f0d56c201d04c8bce74df/gistfile1.txt',
        ),
      ]).then(function ([gdpData, unemploymentData]) {
        //  GDP data
        const gdpByCountry = {
          Sweden: [],
          Norway: [],
          Denmark: [],
        };

        gdpData.forEach((d) => {
          if (gdpByCountry.hasOwnProperty(d['Country'])) {
            gdpByCountry[d['Country']].push({
              country: d['Country'],
              year: +d.Year,
              value: +d['Annual Change (%)'],
            });
          }
        });

        // Sort by year
        Object.keys(gdpByCountry).forEach((country) => {
          gdpByCountry[country].sort(
            (a, b) => a.year - b.year,
          );
        });

        //  unemployment data
        const unemploymentByCountry = {
          Sweden: [],
          Norway: [],
          Denmark: [],
        };

        // parsing based on csv
        const parseDate = d3.timeParse('%b %Y');

        unemploymentData.forEach((d) => {
          if (
            unemploymentByCountry.hasOwnProperty(d.Country)
          ) {
            unemploymentByCountry[d.Country].push({
              country: d.Country,
              date: parseDate(d.Month),
              value: +d['Annual Change (%)'],
            });
          }
        });

        // sort unemployment data by date
        Object.keys(unemploymentByCountry).forEach(
          (country) => {
            unemploymentByCountry[country].sort(
              (a, b) => a.date - b.date,
            );
          },
        );

        createGDPChart(gdpByCountry);

        createUnemploymentChart(unemploymentByCountry);


      });

      // gdp chart function
      function createGDPChart(data) {
        const svg = d3
          .select('#gdp-chart')
          .append('svg')
          .attr('width', width + margin.left + margin.right)
          .attr(
            'height',
            height + margin.top + margin.bottom,
          )
          .append('g')
          .attr(
            'transform',
            `translate(${margin.left},${margin.top})`,
          );

        const allYears = [];
        Object.values(data).forEach((countryData) => {
          countryData.forEach((d) => allYears.push(d.year));
        });

        const minYear = d3.min(allYears);
        const maxYear = d3.max(allYears);

        // min max gdp
        const allValues = [];
        Object.values(data).forEach((countryData) => {
          countryData.forEach((d) =>
            allValues.push(d.value),
          );
        });

        const minValue = d3.min(allValues);
        const maxValue = d3.max(allValues);

        // x and y scales
        const x = d3
          .scaleLinear()
          .domain([minYear, maxYear])
          .range([0, width]);

        const y = d3
          .scaleLinear()
          .domain([
            minValue < 0 ? minValue * 1.1 : 0,
            maxValue * 1.1,
          ])
          .nice()
          .range([height, 0]);

        // line generator
        const line = d3
          .line()
          .x((d) => x(d.year))
          .y((d) => y(d.value))
          .curve(d3.curveMonotoneX);

        // x axis grid lines
        svg
          .append('g')
          .attr('class', 'grid')
          .attr('transform', `translate(0,${height})`)
          .call(
            d3
              .axisBottom(x)
              .ticks(10)
              .tickSize(-height)
              .tickFormat(''),
          );

        // y axis grid lines
        svg
          .append('g')
          .attr('class', 'grid')
          .call(
            d3
              .axisLeft(y)
              .ticks(10)
              .tickSize(-width)
              .tickFormat(''),
          );

        // x axis
        svg
          .append('g')
          .attr('class', 'axis axis-x')
          .attr('transform', `translate(0,${height})`)
          .call(
            d3
              .axisBottom(x)
              .tickValues(d3.range(minYear, maxYear + 1, 1))
              .tickFormat(d3.format('d')),
          );

        // x axis label
        svg
          .append('text')
          .attr('x', width / 2)
          .attr('y', height + 40)
          .attr('text-anchor', 'middle')
          .style('font-size', '14px')
          .text('Year');

        // y axis
        svg
          .append('g')
          .attr('class', 'axis axis-y')
          .call(d3.axisLeft(y));

        // y axis label
        svg
          .append('text')
          .attr('transform', 'rotate(-90)')
          .attr('x', -height / 2)
          .attr('y', -40)
          .attr('text-anchor', 'middle')
          .style('font-size', '14px')
          .text('GDP Annual % Change');

        // lines for each country
        Object.keys(data).forEach((country) => {
          if (data[country].length > 0) {
            const countryLine = svg
              .append('path')
              .datum(data[country])
              .attr(
                'class',
                `line ${country.toLowerCase()}`,
              )
              .attr('d', line)
              .attr('data-country', country);

            //  dots for each data points
            svg
              .selectAll(`.dot-${country.toLowerCase()}`)
              .data(data[country])
              .enter()
              .append('circle')
              .attr('class', `dot-${country.toLowerCase()}`)
              .attr('cx', (d) => x(d.year))
              .attr('cy', (d) => y(d.value))
              .attr('r', 4)
              .attr('fill', colorScale(country))
              .attr('data-country', country)
              .style('cursor', 'pointer')
              .on('mouseover', function (event, d) {
                // when hover over one country
                highlightCountry(d.country);

                tooltip
                  .transition()
                  .duration(200)
                  .style('opacity', 0.9);

                tooltip
                  .html(
                    `
                <strong>${d.country}</strong><br>
                Year: ${d.year}<br>
                GDP Change: <span class="tooltip-value">${d.value.toFixed(2)}%</span>
              `,
                  )
                  .style('left', event.pageX + 10 + 'px')
                  .style('top', event.pageY - 28 + 'px');
              })
              .on('mouseout', function () {
                resetHighlight();

                tooltip
                  .transition()
                  .duration(500)
                  .style('opacity', 0);
              });
          }
        });
      }

      // unemployment chart fucntion
      function createUnemploymentChart(data) {
        // Create SVG container
        const svg = d3
          .select('#unemployment-chart')
          .append('svg')
          .attr('width', width + margin.left + margin.right)
          .attr(
            'height',
            height + margin.top + margin.bottom,
          )
          .append('g')
          .attr(
            'transform',
            `translate(${margin.left},${margin.top})`,
          );

        const allDates = [];
        Object.values(data).forEach((countryData) => {
          countryData.forEach((d) => allDates.push(d.date));
        });

        const minDate = d3.min(allDates);
        const maxDate = d3.max(allDates);

        // min max
        const allValues = [];
        Object.values(data).forEach((countryData) => {
          countryData.forEach((d) =>
            allValues.push(d.value),
          );
        });

        const minValue = d3.min(allValues);
        const maxValue = d3.max(allValues);

        // scales
        const x = d3
          .scaleTime()
          .domain([minDate, maxDate])
          .range([0, width]);

        const y = d3
          .scaleLinear()
          .domain([
            minValue < 0 ? minValue * 1.1 : 0,
            maxValue * 1.1,
          ])
          .nice()
          .range([height, 0]);

        // line generator
        const line = d3
          .line()
          .x((d) => x(d.date))
          .y((d) => y(d.value))
          .curve(d3.curveMonotoneX);

        // x axis grid lines
        svg
          .append('g')
          .attr('class', 'grid')
          .attr('transform', `translate(0,${height})`)
          .call(
            d3
              .axisBottom(x)
              .ticks(10)
              .tickSize(-height)
              .tickFormat(''),
          );

        // y axis grid lines
        svg
          .append('g')
          .attr('class', 'grid')
          .call(
            d3
              .axisLeft(y)
              .ticks(10)
              .tickSize(-width)
              .tickFormat(''),
          );

        // x axis
        svg
          .append('g')
          .attr('class', 'axis axis-x')
          .attr('transform', `translate(0,${height})`)
          .call(
            d3
              .axisBottom(x)
              .ticks(d3.timeYear.every(1))
              .tickFormat(d3.timeFormat('%Y')),
          );

        // x axis label
        svg
          .append('text')
          .attr('x', width / 2)
          .attr('y', height + 40)
          .attr('text-anchor', 'middle')
          .style('font-size', '14px')
          .text('Year');

        // y axis
        svg
          .append('g')
          .attr('class', 'axis axis-y')
          .call(d3.axisLeft(y));

        // y axis label
        svg
          .append('text')
          .attr('transform', 'rotate(-90)')
          .attr('x', -height / 2)
          .attr('y', -40)
          .attr('text-anchor', 'middle')
          .style('font-size', '14px')
          .text('Unemployment Rate Annual Change (%)');

        // lines for each country
        Object.keys(data).forEach((country) => {
          if (data[country].length > 0) {
            const countryLine = svg
              .append('path')
              .datum(data[country])
              .attr(
                'class',
                `line ${country.toLowerCase()}`,
              )
              .attr('d', line)
              .attr('data-country', country);

            // dots for data points
            svg
              .selectAll(
                `.dot-${country.toLowerCase()}-unempl`,
              )
              .data(data[country])
              .enter()
              .append('circle')
              .attr('class', `dot-${country.toLowerCase()}`)
              .attr('cx', (d) => x(d.date))
              .attr('cy', (d) => y(d.value))
              .attr('r', 4)
              .attr('fill', colorScale(country))
              .attr('data-country', country)
              .style('cursor', 'pointer')
              .on('mouseover', function (event, d) {
                highlightCountry(d.country);

                tooltip
                  .transition()
                  .duration(200)
                  .style('opacity', 0.9);

                tooltip
                  .html(
                    `
                <strong>${d.country}</strong><br>
                Date: ${d3.timeFormat('%b %Y')(d.date)}<br>
                Unemployment Change: <span class="tooltip-value">${d.value.toFixed(2)}%</span>
              `,
                  )
                  .style('left', event.pageX + 10 + 'px')
                  .style('top', event.pageY - 28 + 'px');
              })
              .on('mouseout', function () {
                resetHighlight();

                tooltip
                  .transition()
                  .duration(500)
                  .style('opacity', 0);
              });
          }
        });
      }


      // highlighting function
      function highlightCountry(country) {
        // Fade out all lines
        d3.selectAll('.line')
          .classed('faded', true)
          .classed('highlighted', false);

        // Highlight selected country
        d3.selectAll(`.${country.toLowerCase()}`)
          .classed('faded', false)
          .classed('highlighted', true);

        d3.selectAll('circle').style('opacity', 0.2);

        d3.selectAll(
          `circle[data-country="${country}"]`,
        ).style('opacity', 1);

        d3.selectAll('.legend-item').style('opacity', 0.4);

        d3.selectAll(
          `.legend-item[data-country="${country}"]`,
        ).style('opacity', 1);
      }

      // reseting highlight function
      function resetHighlight() {
        d3.selectAll('.line')
          .classed('faded', false)
          .classed('highlighted', false);

        d3.selectAll('circle').style('opacity', 1);

        d3.selectAll('.legend-item').style('opacity', 1);
      }


      // HOSPITALITY SECTION

      const hospitality_margin = {
        top: 20,
        right: 20,
        bottom: 40,
        left: 50,
      };
      const hospitality_width =
        350 -
        hospitality_margin.left -
        hospitality_margin.right;
      const hospitality_height =
        300 -
        hospitality_margin.top -
        hospitality_margin.bottom;

      // Color scale
      const hospitality_colorScale = {
        Sweden: '#9acd32',
        Norway: '#0065A4',
        Denmark: '#8b0000',
      };

      // data
      function loadData() {
        d3.csv(
          'https://gist.githubusercontent.com/karldif01/b47551c67889816e4caa36500377e080/raw/9c9dc3dc1223cf788e663dc5186c8ff279594f6b/gistfile1.txt',
        ).then((csvData) => {
          // Group by country
          const dataByCountry = {
            Denmark: [],
            Norway: [],
            Sweden: [],
          };

          csvData.forEach((d) => {
            if (
              d.indicator === 'Daily hospital occupancy' &&
              dataByCountry.hasOwnProperty(d.Country)
            ) {
              dataByCountry[d.Country].push({
                date: new Date(d.date),
                value: +d.value,
                formattedDate: d.date,
              });
            }
          });

          // Sort by date for each country
          Object.keys(dataByCountry).forEach((country) => {
            dataByCountry[country].sort(
              (a, b) => a.date - b.date,
            );
          });

          // charts
          createChart(
            'denmark-chart',
            dataByCountry['Denmark'],
            'Denmark',
          );
          createChart(
            'norway-chart',
            dataByCountry['Norway'],
            'Norway',
          );
          createChart(
            'sweden-chart',
            dataByCountry['Sweden'],
            'Sweden',
          );

          // combined chart
          createCombinedChart(dataByCountry);
        });
      }

      // line chart
      function createChart(elementId, data, country) {
        const svg = d3
          .select(`#${elementId}`)
          .append('svg')
          .attr(
            'width',
            hospitality_width +
              hospitality_margin.left +
              hospitality_margin.right,
          )
          .attr(
            'height',
            hospitality_height +
              hospitality_margin.top +
              hospitality_margin.bottom,
          )
          .append('g')
          .attr(
            'transform',
            `translate(${hospitality_margin.left},${hospitality_margin.top})`,
          );

        //  scales
        const x = d3
          .scaleTime()
          .domain(d3.extent(data, (d) => d.date))
          .range([0, hospitality_width]);

        const y = d3
          .scaleLinear()
          .domain([0, d3.max(data, (d) => d.value)])
          .nice()
          .range([hospitality_height, 0]);

        svg
          .append('g')
          .attr('class', 'axis-x')
          .attr(
            'transform',
            `translate(0,${hospitality_height})`,
          )
          .call(
            d3
              .axisBottom(x)
              .tickValues([
                // Removed 2020 tick
                new Date('2021-01-01'),
                new Date('2022-01-01'),
              ])
              .tickFormat(d3.timeFormat('%Y')),
          );

        // y axis
        svg
          .append('g')
          .attr('class', 'axis-y')
          .call(d3.axisLeft(y));

        // y axis label
        svg
          .append('text')
          .attr('transform', 'rotate(-90)')
          .attr('y', -40)
          .attr('x', -hospitality_height / 2)
          .attr('text-anchor', 'middle')
          .style('font-size', '12px')
          .text('Hospital Occupancy');

        svg
          .append('path')
          .datum(data)
          .attr(
            'class',
            `line ${country.toLowerCase()}-line`,
          )
          .attr(
            'd',
            d3
              .line()
              .x((d) => x(d.date))
              .y((d) => y(d.value))
              .curve(d3.curveMonotoneX),
          );

        // tooltip area
        const tooltipArea = svg
          .append('rect')
          .attr('width', hospitality_width)
          .attr('height', hospitality_height)
          .style('opacity', 0)
          .style('pointer-events', 'all');

        const bisect = d3.bisector((d) => d.date).left;

        tooltipArea.on('mousemove', function (event) {
          const mouseX = d3.pointer(event)[0];

          const x0 = x.invert(mouseX);

          const i = bisect(data, x0, 1);

          // Handle edge cases
          if (i >= data.length || i <= 0) return;

          // Get the data point
          const d0 = data[i - 1];
          const d1 = data[i];

          // which point is closer
          const d = x0 - d0.date > d1.date - x0 ? d1 : d0;

          // Show tooltip at position
          tooltip
            .transition()
            .duration(200)
            .style('opacity', 0.9);

          tooltip
            .html(
              `
            <strong>${country}</strong><br>
            Date: ${d.formattedDate}<br>
            Hospital Occupancy: <span class="tooltip-value">${d.value}</span>
          `,
            )
            .style('left', event.pageX + 10 + 'px')
            .style('top', event.pageY - 28 + 'px');

          // vertical line at position
          svg.selectAll('.tooltip-line').remove();
          svg
            .append('line')
            .attr('class', 'tooltip-line')
            .attr('x1', x(d.date))
            .attr('x2', x(d.date))
            .attr('y1', 0)
            .attr('y2', hospitality_height)
            .style('stroke', 'rgba(0,0,0,0.2)')
            .style('stroke-width', 1)
            .style('stroke-dasharray', '3,3');

          // circle at that position
          svg.selectAll('.tooltip-circle').remove();
          svg
            .append('circle')
            .attr('class', 'tooltip-circle')
            .attr('cx', x(d.date))
            .attr('cy', y(d.value))
            .attr('r', 4)
            .style('fill', hospitality_colorScale[country])
            .style('stroke', '#fff')
            .style('stroke-width', 2);
        });

        tooltipArea.on('mouseout', function () {
          tooltip
            .transition()
            .duration(500)
            .style('opacity', 0);

          svg.selectAll('.tooltip-line').remove();
          svg.selectAll('.tooltip-circle').remove();
        });
      }

      loadData();

      

      // combined chart
      function createCombinedChart(allData) {
        // fill width
        const combinedMargin = {
          top: 20,
          right: 30,
          bottom: 40,
          left: 50,
        };
        const combinedWidth =
          1100 - combinedMargin.left - combinedMargin.right;
        const combinedHeight =
          400 - combinedMargin.top - combinedMargin.bottom;

        const svg = d3
          .select('#combined-chart')
          .append('svg')
          .attr(
            'width',
            combinedWidth +
              combinedMargin.left +
              combinedMargin.right,
          )
          .attr(
            'height',
            combinedHeight +
              combinedMargin.top +
              combinedMargin.bottom,
          )
          .append('g')
          .attr(
            'transform',
            `translate(${combinedMargin.left},${combinedMargin.top})`,
          );

        const allPoints = [];
        Object.keys(allData).forEach((country) => {
          allData[country].forEach((d) =>
            allPoints.push({ ...d, country: country }),
          );
        });

        // scales
        const x = d3
          .scaleTime()
          .domain(d3.extent(allPoints, (d) => d.date))
          .range([0, combinedWidth]);

        const y = d3
          .scaleLinear()
          .domain([0, d3.max(allPoints, (d) => d.value)])
          .nice()
          .range([combinedHeight, 0]);

        // x axis
        svg
          .append('g')
          .attr('class', 'axis-x')
          .attr(
            'transform',
            `translate(0,${combinedHeight})`,
          )
          .call(
            d3
              .axisBottom(x)
              .tickValues([
                // Keep all ticks for combined chart
                new Date('2020-03-13'),
                new Date('2021-01-01'),
                new Date('2022-01-01'),
              ])
              .tickFormat(d3.timeFormat('%Y')),
          );

        // y axis
        svg
          .append('g')
          .attr('class', 'axis-y')
          .call(d3.axisLeft(y));

        // y axis label
        svg
          .append('text')
          .attr('transform', 'rotate(-90)')
          .attr('y', -40)
          .attr('x', -combinedHeight / 2)
          .attr('text-anchor', 'middle')
          .style('font-size', '12px')
          .text('Hospital Occupancy');

        const line = d3
          .line()
          .x((d) => x(d.date))
          .y((d) => y(d.value))
          .curve(d3.curveMonotoneX);

        // lines for each country
        Object.keys(allData).forEach((country) => {
          svg
            .append('path')
            .datum(allData[country])
            .attr(
              'class',
              `line ${country.toLowerCase()}-line`,
            )
            .attr('d', line);
        });

        function createLegend(containerId, countries) {
          const legendContainer = d3.select(`#${containerId}`);
          countries.forEach(country => {
            const item = legendContainer.append('div')
              .attr('class','legend-item')
              .attr('data-country',country)
              .on('mouseover', ()=>highlightCountry(country))
              .on('mouseout',  ()=>resetHighlight());
            item.append('div')
              .attr('class','legend-color')
              .style('background-color', colorScale(country));
            item.append('span').text(country);
          });
        }

        // then, after you draw each chart:
        createLegend('gdp-legend',           ['Sweden','Norway','Denmark']);
        createLegend('unemployment-legend',  ['Sweden','Norway','Denmark']);
        createLegend('combined-legend',      ['Sweden','Norway','Denmark']);

        // tooltip area for combined chart
        const tooltipArea = svg
          .append('rect')
          .attr('width', combinedWidth)
          .attr('height', combinedHeight)
          .style('opacity', 0)
          .style('pointer-events', 'all');

        tooltipArea.on('mousemove', function (event) {
          const mouseX = d3.pointer(event)[0];

          const x0 = x.invert(mouseX);

          let closestPoints = [];
          Object.keys(allData).forEach((country) => {
            const bisect = d3.bisector((d) => d.date).left;
            const i = bisect(allData[country], x0, 1);

            // edge cases
            if (i >= allData[country].length || i <= 0)
              return;

            const d0 = allData[country][i - 1];
            const d1 = allData[country][i];

            // find which point is closer
            const d = x0 - d0.date > d1.date - x0 ? d1 : d0;
            closestPoints.push({ ...d, country: country });
          });

          if (closestPoints.length === 0) return;

          svg.selectAll('.tooltip-line').remove();
          svg.selectAll('.tooltip-circle').remove();

          // vertical line
          const tooltipDate = closestPoints[0].date;
          svg
            .append('line')
            .attr('class', 'tooltip-line')
            .attr('x1', x(tooltipDate))
            .attr('x2', x(tooltipDate))
            .attr('y1', 0)
            .attr('y2', combinedHeight)
            .style('stroke', 'rgba(0,0,0,0.2)')
            .style('stroke-width', 1)
            .style('stroke-dasharray', '3,3');

          // tooltip circle
          closestPoints.forEach((d) => {
            svg
              .append('circle')
              .attr('class', 'tooltip-circle')
              .attr('cx', x(d.date))
              .attr('cy', y(d.value))
              .attr('r', 4)
              .style(
                'fill',
                hospitality_colorScale[d.country],
              )
              .style('stroke', '#fff')
              .style('stroke-width', 2);
          });

          tooltip
            .transition()
            .duration(200)
            .style('opacity', 0.9);

          let tooltipHtml = `<strong>Date: ${closestPoints[0].formattedDate}</strong><br>`;

          closestPoints.forEach((d) => {
            tooltipHtml += `${d.country}: <span class="tooltip-value">${d.value}</span><br>`;
          });

          tooltip
            .html(tooltipHtml)
            .style('left', event.pageX + 10 + 'px')
            .style('top', event.pageY - 28 + 'px');
        });

        tooltipArea.on('mouseout', function () {
          tooltip
            .transition()
            .duration(500)
            .style('opacity', 0);

          svg.selectAll('.tooltip-line').remove();
          svg.selectAll('.tooltip-circle').remove();
        });
      }


      // Mortality Section

      const mortality_margin = {
        top: 20,
        right: 30,
        bottom: 40,
        left: 60,
      },
      mortality_width = 800 - mortality_margin.left - mortality_margin.right,
      mortality_height = 550 - mortality_margin.top - mortality_margin.bottom;

      const parseDate = d3.timeParse('%Y-%m-%d'),
        formatDate = d3.timeFormat('%Y-%m-%d');

      const svg = d3
        .select('#chart')
        .append('svg')
        .attr(
          'width',
          mortality_width +
            mortality_margin.left +
            mortality_margin.right,
        )
        .attr(
          'height',
          mortality_height +
            mortality_margin.top +
            mortality_margin.bottom,
        )
        .append('g')
        .attr(
          'transform',
          `translate(${mortality_margin.left},${mortality_margin.top})`,
        );


      d3.csv(
        'https://gist.githubusercontent.com/karldif01/e0beb4b117aa3dc68c55510e05f41a64/raw/89705d1aca641526463cae1ddc4aca49987b5a86/gistfile1.txt',
        (d) => ({
          Country: d.Country,
          date: parseDate(d.date),
          total_deaths: +d.deaths_per_10m,
        }),
      ).then((data) => {
        data.sort((a, b) => d3.ascending(a.date, b.date));

        const dataByCountry = d3.group(
            data,
            (d) => d.Country,
          ),
          countries = Array.from(dataByCountry.keys()),
          dates = Array.from(
            new Set(data.map((d) => +d.date)),
          )
            .sort()
            .map((t) => new Date(t));

        // scales
        const x = d3
          .scaleTime()
          .domain(d3.extent(dates))
          .range([0, mortality_width]);
        const y = d3
          .scaleLinear()
          .domain([0, d3.max(data, (d) => d.total_deaths)])
          .nice()
          .range([mortality_height, 0]);
        const rScale = d3
          .scaleSqrt()
          .domain([0, d3.max(data, (d) => d.total_deaths)])
          .range([2, 12]);

        // grid & axes
        svg
          .append('g')
          .attr('class', 'grid')
          .call(
            d3
              .axisLeft(y)
              .tickSize(-mortality_width)
              .tickFormat(''),
          )
          .lower();

        svg
          .append('g')
          .attr('class', 'axis')
          .attr(
            'transform',
            `translate(0,${mortality_height})`,
          )
          .call(d3.axisBottom(x));

        svg
          .append('g')
          .attr('class', 'axis')
          .call(d3.axisLeft(y));

        svg
          .append('text')
          .attr('x', mortality_width / 2)
          .attr(
            'y',
            mortality_height + mortality_margin.bottom - 5,
          )
          .attr('text-anchor', 'middle')
          .text('Date');

        svg
          .append('text')
          .attr('transform', 'rotate(-90)')
          .attr('x', -mortality_height / 2)
          .attr('y', -mortality_margin.left + 15)
          .attr('text-anchor', 'middle')
          .text('Deaths Per 10 Million');

        const mortality_color = {
          Sweden: 'YellowGreen',
          Norway: 'steelblue',
          Denmark: 'darkred',
        };
        const lineGen = d3
          .line()
          .x((d) => d[0])
          .y((d) => d[1]);

        // to backtrack history of points
        const history = new Map();
        countries.forEach((c) => history.set(c, []));

        const trails = svg
          .selectAll('.trail')
          .data(countries)
          .enter()
          .append('path')
          .attr('class', 'trail')
          .attr('stroke', (d) => mortality_color[d]);

        const mortality_dots = svg
          .selectAll('.mortality_dot')
          .data(countries)
          .enter()
          .append('circle')
          .attr('class', 'mortality_dot')
          .attr('fill', (d) => mortality_color[d])
          .on('mouseover', (event, country) => {
            // get current record for this country at current idx
            const rec = dataByCountry.get(country)[idx];
            tooltip.style('opacity', 1).html(
              `<strong>${country}</strong><br/>
                                 ${formatDate(rec.date)}<br/>
                                 Deaths per 10M: ${Math.round(rec.total_deaths)}`,
            );
          })
          .on('mousemove', (event) => {
            tooltip
              .style('left', event.pageX + 10 + 'px')
              .style('top', event.pageY + 10 + 'px');
          })
          .on('mouseout', () => {
            tooltip.style('opacity', 0);
          });

        // slider
        const slider = d3
          .select('#date-slider')
          .attr('max', dates.length - 1)
          .property('value', 0)
          .on('input', function () {
            idx = +this.value;
            updateChart();
          });
        const dateLabel = d3.select(
          '#mortality-current-date',
        );

        // animation logic
        //idx tracks which date is currently displayed
        let idx = 0,
          timer;
        d3.select('#play').on('click', () => {
          if (timer) {
            clearInterval(timer);
            timer = null;
            d3.select('#play').text('Play');
          } else {
            d3.select('#play').text('Pause');
            timer = setInterval(() => {
              idx = Math.min(idx + 1, dates.length - 1);
              slider.property('value', idx);
              updateChart();
              if (idx === dates.length - 1) {
                clearInterval(timer);
                timer = null;
                d3.select('#play').text('Play');
              }
            }, 10);
          }
        });

        // update function
        function updateChart() {
          countries.forEach((country) => {
            const recs = dataByCountry
              .get(country)
              .slice(0, idx + 1);
            const hist = recs.map((r) => [
              x(r.date),
              y(r.total_deaths),
            ]);
            history.set(country, hist);
          });
          trails.attr('d', (d) => lineGen(history.get(d)));
          mortality_dots
            .attr('cx', (d) =>
              x(dataByCountry.get(d)[idx].date),
            )
            .attr('cy', (d) =>
              y(dataByCountry.get(d)[idx].total_deaths),
            )
            .attr('r', (d) =>
              rScale(
                dataByCountry.get(d)[idx].total_deaths,
              ),
            );
          dateLabel.text(formatDate(dates[idx]));
        }

        updateChart();
      });




      const width = 800,
        height = 600;

      const svg = d3
        .select('#map-container')
        .append('svg')
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      // tooltip

      Promise.all([
        d3.json(
          'https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json',
        ),
        d3.csv(
          'https://gist.githubusercontent.com/karldif01/9daa30f0d38b7cd36f17872e5a893729/raw/4d7eff95c8cf5d6e5e1b0d79990863d8dccf4c07/gistfile1.txt',
          (d) => ({
            country: d.Country,
            date: new Date(d.date),
            cases: +d.total_cases,
          }),
        ),
      ]).then(([geo, rows]) => {
        //filter only scandinavian countries
        const scandi = new Set([
          'Sweden',
          'Denmark',
          'Norway',
        ]);
        geo.features = geo.features.filter((f) =>
          scandi.has(f.properties.name),
        );

        // data by date
        const dataByDate = d3.group(rows, (d) => +d.date);
        const dates = Array.from(dataByDate.keys()).sort(
          (a, b) => a - b,
        );

        // lookup for timestamp
        const lookup = new Map();
        dataByDate.forEach((recs, t) => {
          lookup.set(
            t,
            new Map(recs.map((r) => [r.country, r.cases])),
          );
        });

        const projection = d3
          .geoMercator()
          .fitSize([width, height], geo);
        const path = d3.geoPath().projection(projection);

        // set a fix max
        const maxColorValue = 3500000;

        // color scale
        const color = d3
          .scaleSequential(d3.interpolateOrRd)
          .domain([0, maxColorValue]);

        const countries = svg
          .append('g')
          .selectAll('path')
          .data(geo.features)
          .join('path')
          .attr('class', 'country')
          .attr('d', path)
          .attr('fill', '#eee');

        countries
          .on('mouseover', function (event, d) {
            tooltip
              .style('display', 'block')
              .style('left', event.pageX + 10 + 'px')
              .style('top', event.pageY - 28 + 'px');
          })
          .on('mousemove', function (event) {
            tooltip
              .style('left', event.pageX + 10 + 'px')
              .style('top', event.pageY - 28 + 'px');
          })
          .on('mouseout', function () {
            tooltip.style('display', 'none');
          });

        // slider setup
        const slider = d3
          .select('#date-slider')
          .attr('max', dates.length - 1)
          .property('value', 0)
          .on('input', update);

        // date label
        d3.select('#heatmap-current-date').text(
          d3.timeFormat('%Y-%m-%d')(new Date(dates[0])),
        );

        // legend
        const legendWidth = 200;
        const legendHeight = 20;

        // legend container
        const legend = d3
          .select('#map-container')
          .append('div')
          .attr('class', 'legend');

        legend
          .append('div')
          .attr('class', 'legend-title')
          .text('COVID-19 Cases');

        const legendContainer = legend
          .append('div')
          .attr('class', 'legend-container');

        // legend gradient
        const legendSvg = legendContainer
          .append('svg')
          .attr('width', legendWidth)
          .attr('height', legendHeight);

        // linear gradient
        const defs = legendSvg.append('defs');
        const linearGradient = defs
          .append('linearGradient')
          .attr('id', 'legend-gradient')
          .attr('x1', '0%')
          .attr('y1', '0%')
          .attr('x2', '100%')
          .attr('y2', '0%');

        const numStops = 10;
        for (let i = 0; i <= numStops; i++) {
          const offset = i / numStops;
          const stopValue = offset * maxColorValue;
          linearGradient
            .append('stop')
            .attr('offset', `${offset * 100}%`)
            .attr('stop-color', color(stopValue));
        }
        // rect for gradient
        legendSvg
          .append('rect')
          .attr('width', legendWidth)
          .attr('height', legendHeight)
          .style('fill', 'url(#legend-gradient)');

        const legendLabels = legend
          .append('div')
          .style('display', 'flex')
          .style('justify-content', 'space-between')
          .style('font-size', '12px');

        legendLabels.append('span').text('0');

        legendLabels.append('span').text('3.5M');

        update();

        function update() {
          const i = +slider.property('value');
          const t = dates[i];
          const dateStr = d3.timeFormat('%Y-%m-%d')(
            new Date(t),
          );
          d3.select('#heatmap-current-date').text(dateStr);

          const todayMap = lookup.get(t);

          countries
            .attr('fill', (d) => {
              const name = d.properties.name;
              const c = todayMap.get(name) || 0;
              return c ? color(c) : '#ccc';
            })
            .on('mouseover', function (event, d) {
              const name = d.properties.name;
              const c = todayMap.get(name) || 0;

              tooltip
                .style('display', 'block')
                .style('left', event.pageX + 10 + 'px')
                .style('top', event.pageY - 28 + 'px')
                .html(
                  `<strong>${name}</strong><br/>Date: ${dateStr}<br/>Cases: ${c.toLocaleString()}`,
                );
            });
        }
      });

      </script>







  </body>
</html>